/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
impl ::std::default::Default for __fsid_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = isize;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type size_t = usize;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint_ = ::std::os::raw::c_uint;
pub type int8_t = i8;
pub type int16_t = i16;
pub type int32_t = i32;
pub type int64_t = i64;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
impl ::std::default::Default for __sigset_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
impl ::std::default::Default for timespec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
impl ::std::default::Default for timeval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
impl ::std::default::Default for fd_set {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct pthread_attr_t {
    pub _bindgen_data_: [u64; 7usize],
}
impl pthread_attr_t {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for pthread_attr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
impl ::std::default::Default for __pthread_internal_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub struct pthread_mutex_t {
    pub _bindgen_data_: [u64; 5usize],
}
impl pthread_mutex_t {
    pub unsafe fn __data(&mut self) -> *mut __pthread_mutex_s {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 40usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for pthread_mutex_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
impl ::std::default::Default for __pthread_mutex_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_mutexattr_t {
    pub _bindgen_data_: [u32; 1usize],
}
impl pthread_mutexattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_mutexattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pthread_cond_t {
    pub _bindgen_data_: [u64; 6usize],
}
impl pthread_cond_t {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed1 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 48usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_longlong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for pthread_cond_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_condattr_t {
    pub _bindgen_data_: [u32; 1usize],
}
impl pthread_condattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_condattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct pthread_rwlock_t {
    pub _bindgen_data_: [u64; 7usize],
}
impl pthread_rwlock_t {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed2 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for pthread_rwlock_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed2 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __pad1: ::std::os::raw::c_ulong,
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
    _bindgen_padding_0_: [u8; 4usize],
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_rwlockattr_t {
    pub _bindgen_data_: [u64; 1usize],
}
impl pthread_rwlockattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 8usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_rwlockattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_barrier_t {
    pub _bindgen_data_: [u64; 4usize],
}
impl pthread_barrier_t {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 32usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_barrier_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_barrierattr_t {
    pub _bindgen_data_: [u32; 1usize],
}
impl pthread_barrierattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_barrierattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type my_bool = ::std::os::raw::c_char;
pub type my_socket = ::std::os::raw::c_int;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum enum_server_command {
    COM_SLEEP = 0,
    COM_QUIT = 1,
    COM_INIT_DB = 2,
    COM_QUERY = 3,
    COM_FIELD_LIST = 4,
    COM_CREATE_DB = 5,
    COM_DROP_DB = 6,
    COM_REFRESH = 7,
    COM_SHUTDOWN = 8,
    COM_STATISTICS = 9,
    COM_PROCESS_INFO = 10,
    COM_CONNECT = 11,
    COM_PROCESS_KILL = 12,
    COM_DEBUG = 13,
    COM_PING = 14,
    COM_TIME = 15,
    COM_DELAYED_INSERT = 16,
    COM_CHANGE_USER = 17,
    COM_BINLOG_DUMP = 18,
    COM_TABLE_DUMP = 19,
    COM_CONNECT_OUT = 20,
    COM_REGISTER_SLAVE = 21,
    COM_STMT_PREPARE = 22,
    COM_STMT_EXECUTE = 23,
    COM_STMT_SEND_LONG_DATA = 24,
    COM_STMT_CLOSE = 25,
    COM_STMT_RESET = 26,
    COM_SET_OPTION = 27,
    COM_STMT_FETCH = 28,
    COM_DAEMON = 29,
    COM_END = 30,
}
pub enum st_vio { }
pub type Vio = st_vio;
#[repr(C)]
#[derive(Copy)]
pub struct st_net {
    pub vio: *mut Vio,
    pub buff: *mut ::std::os::raw::c_uchar,
    pub buff_end: *mut ::std::os::raw::c_uchar,
    pub write_pos: *mut ::std::os::raw::c_uchar,
    pub read_pos: *mut ::std::os::raw::c_uchar,
    pub fd: my_socket,
    pub remain_in_buf: ::std::os::raw::c_ulong,
    pub length: ::std::os::raw::c_ulong,
    pub buf_length: ::std::os::raw::c_ulong,
    pub where_b: ::std::os::raw::c_ulong,
    pub max_packet: ::std::os::raw::c_ulong,
    pub max_packet_size: ::std::os::raw::c_ulong,
    pub pkt_nr: ::std::os::raw::c_uint,
    pub compress_pkt_nr: ::std::os::raw::c_uint,
    pub write_timeout: ::std::os::raw::c_uint,
    pub read_timeout: ::std::os::raw::c_uint,
    pub retry_count: ::std::os::raw::c_uint,
    pub fcntl: ::std::os::raw::c_int,
    pub return_status: *mut ::std::os::raw::c_uint,
    pub reading_or_writing: ::std::os::raw::c_uchar,
    pub save_char: ::std::os::raw::c_char,
    pub unused1: my_bool,
    pub unused2: my_bool,
    pub compress: my_bool,
    pub unused3: my_bool,
    pub unused: *mut ::std::os::raw::c_uchar,
    pub last_errno: ::std::os::raw::c_uint,
    pub error: ::std::os::raw::c_uchar,
    pub unused4: my_bool,
    pub unused5: my_bool,
    pub last_error: [::std::os::raw::c_char; 512usize],
    pub sqlstate: [::std::os::raw::c_char; 6usize],
    pub extension: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for st_net {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for st_net {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NET = st_net;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum enum_field_types {
    MYSQL_TYPE_DECIMAL = 0,
    MYSQL_TYPE_TINY = 1,
    MYSQL_TYPE_SHORT = 2,
    MYSQL_TYPE_LONG = 3,
    MYSQL_TYPE_FLOAT = 4,
    MYSQL_TYPE_DOUBLE = 5,
    MYSQL_TYPE_NULL = 6,
    MYSQL_TYPE_TIMESTAMP = 7,
    MYSQL_TYPE_LONGLONG = 8,
    MYSQL_TYPE_INT24 = 9,
    MYSQL_TYPE_DATE = 10,
    MYSQL_TYPE_TIME = 11,
    MYSQL_TYPE_DATETIME = 12,
    MYSQL_TYPE_YEAR = 13,
    MYSQL_TYPE_NEWDATE = 14,
    MYSQL_TYPE_VARCHAR = 15,
    MYSQL_TYPE_BIT = 16,
    MYSQL_TYPE_NEWDECIMAL = 246,
    MYSQL_TYPE_ENUM = 247,
    MYSQL_TYPE_SET = 248,
    MYSQL_TYPE_TINY_BLOB = 249,
    MYSQL_TYPE_MEDIUM_BLOB = 250,
    MYSQL_TYPE_LONG_BLOB = 251,
    MYSQL_TYPE_BLOB = 252,
    MYSQL_TYPE_VAR_STRING = 253,
    MYSQL_TYPE_STRING = 254,
    MYSQL_TYPE_GEOMETRY = 255,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum mysql_enum_shutdown_level {
    SHUTDOWN_DEFAULT = 0,
    SHUTDOWN_WAIT_CONNECTIONS = 1,
    SHUTDOWN_WAIT_TRANSACTIONS = 2,
    SHUTDOWN_WAIT_UPDATES = 8,
    SHUTDOWN_WAIT_ALL_BUFFERS = 16,
    SHUTDOWN_WAIT_CRITICAL_BUFFERS = 17,
    KILL_QUERY = 254,
    KILL_CONNECTION = 255,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum enum_cursor_type {
    CURSOR_TYPE_NO_CURSOR = 0,
    CURSOR_TYPE_READ_ONLY = 1,
    CURSOR_TYPE_FOR_UPDATE = 2,
    CURSOR_TYPE_SCROLLABLE = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum enum_mysql_set_option {
    MYSQL_OPTION_MULTI_STATEMENTS_ON = 0,
    MYSQL_OPTION_MULTI_STATEMENTS_OFF = 1,
}
pub enum sockaddr { }
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rand_struct {
    pub seed1: ::std::os::raw::c_ulong,
    pub seed2: ::std::os::raw::c_ulong,
    pub max_value: ::std::os::raw::c_ulong,
    pub max_value_dbl: ::std::os::raw::c_double,
}
impl ::std::default::Default for rand_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Item_result {
    STRING_RESULT = 0,
    REAL_RESULT = 1,
    INT_RESULT = 2,
    ROW_RESULT = 3,
    DECIMAL_RESULT = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_udf_args {
    pub arg_count: ::std::os::raw::c_uint,
    pub arg_type: *mut Item_result,
    pub args: *mut *mut ::std::os::raw::c_char,
    pub lengths: *mut ::std::os::raw::c_ulong,
    pub maybe_null: *mut ::std::os::raw::c_char,
    pub attributes: *mut *mut ::std::os::raw::c_char,
    pub attribute_lengths: *mut ::std::os::raw::c_ulong,
    pub extension: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for st_udf_args {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type UDF_ARGS = st_udf_args;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_udf_init {
    pub maybe_null: my_bool,
    pub decimals: ::std::os::raw::c_uint,
    pub max_length: ::std::os::raw::c_ulong,
    pub ptr: *mut ::std::os::raw::c_char,
    pub const_item: my_bool,
    pub extension: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for st_udf_init {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type UDF_INIT = st_udf_init;
#[derive(Copy, Clone)]
#[repr(i32)]
#[derive(Debug)]
pub enum enum_mysql_timestamp_type {
    MYSQL_TIMESTAMP_NONE = -2,
    MYSQL_TIMESTAMP_ERROR = -1,
    MYSQL_TIMESTAMP_DATE = 0,
    MYSQL_TIMESTAMP_DATETIME = 1,
    MYSQL_TIMESTAMP_TIME = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_mysql_time {
    pub year: ::std::os::raw::c_uint,
    pub month: ::std::os::raw::c_uint,
    pub day: ::std::os::raw::c_uint,
    pub hour: ::std::os::raw::c_uint,
    pub minute: ::std::os::raw::c_uint,
    pub second: ::std::os::raw::c_uint,
    pub second_part: ::std::os::raw::c_ulong,
    pub neg: my_bool,
    pub time_type: enum_mysql_timestamp_type,
}
impl ::std::default::Default for st_mysql_time {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MYSQL_TIME = st_mysql_time;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_list {
    pub prev: *mut st_list,
    pub next: *mut st_list,
    pub data: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for st_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LIST = st_list;
pub type list_walk_action =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_mysql_field {
    pub name: *mut ::std::os::raw::c_char,
    pub org_name: *mut ::std::os::raw::c_char,
    pub table: *mut ::std::os::raw::c_char,
    pub org_table: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub catalog: *mut ::std::os::raw::c_char,
    pub def: *mut ::std::os::raw::c_char,
    pub length: ::std::os::raw::c_ulong,
    pub max_length: ::std::os::raw::c_ulong,
    pub name_length: ::std::os::raw::c_uint,
    pub org_name_length: ::std::os::raw::c_uint,
    pub table_length: ::std::os::raw::c_uint,
    pub org_table_length: ::std::os::raw::c_uint,
    pub db_length: ::std::os::raw::c_uint,
    pub catalog_length: ::std::os::raw::c_uint,
    pub def_length: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub decimals: ::std::os::raw::c_uint,
    pub charsetnr: ::std::os::raw::c_uint,
    pub type_: enum_field_types,
    pub extension: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for st_mysql_field {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MYSQL_FIELD = st_mysql_field;
pub type MYSQL_ROW = *mut *mut ::std::os::raw::c_char;
pub type MYSQL_FIELD_OFFSET = ::std::os::raw::c_uint;
pub type my_ulonglong = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_used_mem {
    pub next: *mut st_used_mem,
    pub left: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
}
impl ::std::default::Default for st_used_mem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type USED_MEM = st_used_mem;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_mem_root {
    pub free: *mut USED_MEM,
    pub used: *mut USED_MEM,
    pub pre_alloc: *mut USED_MEM,
    pub min_malloc: size_t,
    pub block_size: size_t,
    pub block_num: ::std::os::raw::c_uint,
    pub first_block_usage: ::std::os::raw::c_uint,
    pub error_handler: ::std::option::Option<extern "C" fn()>,
}
impl ::std::default::Default for st_mem_root {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MEM_ROOT = st_mem_root;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_typelib {
    pub count: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub type_names: *mut *const ::std::os::raw::c_char,
    pub type_lengths: *mut ::std::os::raw::c_uint,
}
impl ::std::default::Default for st_typelib {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TYPELIB = st_typelib;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_mysql_rows {
    pub next: *mut st_mysql_rows,
    pub data: MYSQL_ROW,
    pub length: ::std::os::raw::c_ulong,
}
impl ::std::default::Default for st_mysql_rows {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MYSQL_ROWS = st_mysql_rows;
pub type MYSQL_ROW_OFFSET = *mut MYSQL_ROWS;
pub enum embedded_query_result { }
pub type EMBEDDED_QUERY_RESULT = embedded_query_result;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_mysql_data {
    pub data: *mut MYSQL_ROWS,
    pub embedded_info: *mut embedded_query_result,
    pub alloc: MEM_ROOT,
    pub rows: my_ulonglong,
    pub fields: ::std::os::raw::c_uint,
    pub extension: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for st_mysql_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MYSQL_DATA = st_mysql_data;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum mysql_option {
    MYSQL_OPT_CONNECT_TIMEOUT = 0,
    MYSQL_OPT_COMPRESS = 1,
    MYSQL_OPT_NAMED_PIPE = 2,
    MYSQL_INIT_COMMAND = 3,
    MYSQL_READ_DEFAULT_FILE = 4,
    MYSQL_READ_DEFAULT_GROUP = 5,
    MYSQL_SET_CHARSET_DIR = 6,
    MYSQL_SET_CHARSET_NAME = 7,
    MYSQL_OPT_LOCAL_INFILE = 8,
    MYSQL_OPT_PROTOCOL = 9,
    MYSQL_SHARED_MEMORY_BASE_NAME = 10,
    MYSQL_OPT_READ_TIMEOUT = 11,
    MYSQL_OPT_WRITE_TIMEOUT = 12,
    MYSQL_OPT_USE_RESULT = 13,
    MYSQL_OPT_USE_REMOTE_CONNECTION = 14,
    MYSQL_OPT_USE_EMBEDDED_CONNECTION = 15,
    MYSQL_OPT_GUESS_CONNECTION = 16,
    MYSQL_SET_CLIENT_IP = 17,
    MYSQL_SECURE_AUTH = 18,
    MYSQL_REPORT_DATA_TRUNCATION = 19,
    MYSQL_OPT_RECONNECT = 20,
    MYSQL_OPT_SSL_VERIFY_SERVER_CERT = 21,
    MYSQL_PLUGIN_DIR = 22,
    MYSQL_DEFAULT_AUTH = 23,
    MYSQL_ENABLE_CLEARTEXT_PLUGIN = 24,
}
pub enum st_mysql_options_extention { }
pub enum st_dynamic_array { }
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_mysql_options {
    pub connect_timeout: ::std::os::raw::c_uint,
    pub read_timeout: ::std::os::raw::c_uint,
    pub write_timeout: ::std::os::raw::c_uint,
    pub port: ::std::os::raw::c_uint,
    pub protocol: ::std::os::raw::c_uint,
    pub client_flag: ::std::os::raw::c_ulong,
    pub host: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub password: *mut ::std::os::raw::c_char,
    pub unix_socket: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub init_commands: *mut st_dynamic_array,
    pub my_cnf_file: *mut ::std::os::raw::c_char,
    pub my_cnf_group: *mut ::std::os::raw::c_char,
    pub charset_dir: *mut ::std::os::raw::c_char,
    pub charset_name: *mut ::std::os::raw::c_char,
    pub ssl_key: *mut ::std::os::raw::c_char,
    pub ssl_cert: *mut ::std::os::raw::c_char,
    pub ssl_ca: *mut ::std::os::raw::c_char,
    pub ssl_capath: *mut ::std::os::raw::c_char,
    pub ssl_cipher: *mut ::std::os::raw::c_char,
    pub shared_memory_base_name: *mut ::std::os::raw::c_char,
    pub max_allowed_packet: ::std::os::raw::c_ulong,
    pub use_ssl: my_bool,
    pub compress: my_bool,
    pub named_pipe: my_bool,
    pub unused1: my_bool,
    pub unused2: my_bool,
    pub unused3: my_bool,
    pub unused4: my_bool,
    pub methods_to_use: mysql_option,
    pub client_ip: *mut ::std::os::raw::c_char,
    pub secure_auth: my_bool,
    pub report_data_truncation: my_bool,
    pub local_infile_init: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut *mut ::std::os::raw::c_void,
                                                                      arg2:
                                                                          *const ::std::os::raw::c_char,
                                                                      arg3:
                                                                          *mut ::std::os::raw::c_void)
                                                     ->
                                                         ::std::os::raw::c_int>,
    pub local_infile_read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::std::os::raw::c_void,
                                                                      arg2:
                                                                          *mut ::std::os::raw::c_char,
                                                                      arg3:
                                                                          ::std::os::raw::c_uint)
                                                     ->
                                                         ::std::os::raw::c_int>,
    pub local_infile_end: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_void)>,
    pub local_infile_error: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::std::os::raw::c_void,
                                                                       arg2:
                                                                           *mut ::std::os::raw::c_char,
                                                                       arg3:
                                                                           ::std::os::raw::c_uint)
                                                      ->
                                                          ::std::os::raw::c_int>,
    pub local_infile_userdata: *mut ::std::os::raw::c_void,
    pub extension: *mut st_mysql_options_extention,
}
impl ::std::default::Default for st_mysql_options {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum mysql_status {
    MYSQL_STATUS_READY = 0,
    MYSQL_STATUS_GET_RESULT = 1,
    MYSQL_STATUS_USE_RESULT = 2,
    MYSQL_STATUS_STATEMENT_GET_RESULT = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum mysql_protocol_type {
    MYSQL_PROTOCOL_DEFAULT = 0,
    MYSQL_PROTOCOL_TCP = 1,
    MYSQL_PROTOCOL_SOCKET = 2,
    MYSQL_PROTOCOL_PIPE = 3,
    MYSQL_PROTOCOL_MEMORY = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct character_set {
    pub number: ::std::os::raw::c_uint,
    pub state: ::std::os::raw::c_uint,
    pub csname: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub comment: *const ::std::os::raw::c_char,
    pub dir: *const ::std::os::raw::c_char,
    pub mbminlen: ::std::os::raw::c_uint,
    pub mbmaxlen: ::std::os::raw::c_uint,
}
impl ::std::default::Default for character_set {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MY_CHARSET_INFO = character_set;
pub enum st_mysql_methods { }
pub enum charset_info_st { }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct st_mysql {
    pub net: NET,
    pub connector_fd: *mut ::std::os::raw::c_uchar,
    pub host: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub passwd: *mut ::std::os::raw::c_char,
    pub unix_socket: *mut ::std::os::raw::c_char,
    pub server_version: *mut ::std::os::raw::c_char,
    pub host_info: *mut ::std::os::raw::c_char,
    pub info: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub charset: *mut charset_info_st,
    pub fields: *mut MYSQL_FIELD,
    pub field_alloc: MEM_ROOT,
    pub affected_rows: my_ulonglong,
    pub insert_id: my_ulonglong,
    pub extra_info: my_ulonglong,
    pub thread_id: ::std::os::raw::c_ulong,
    pub packet_length: ::std::os::raw::c_ulong,
    pub port: ::std::os::raw::c_uint,
    pub client_flag: ::std::os::raw::c_ulong,
    pub server_capabilities: ::std::os::raw::c_ulong,
    pub protocol_version: ::std::os::raw::c_uint,
    pub field_count: ::std::os::raw::c_uint,
    pub server_status: ::std::os::raw::c_uint,
    pub server_language: ::std::os::raw::c_uint,
    pub warning_count: ::std::os::raw::c_uint,
    pub options: st_mysql_options,
    pub status: mysql_status,
    pub free_me: my_bool,
    pub reconnect: my_bool,
    pub scramble: [::std::os::raw::c_char; 21usize],
    pub unused1: my_bool,
    pub unused2: *mut ::std::os::raw::c_void,
    pub unused3: *mut ::std::os::raw::c_void,
    pub unused4: *mut ::std::os::raw::c_void,
    pub unused5: *mut ::std::os::raw::c_void,
    pub stmts: *mut LIST,
    pub methods: *const st_mysql_methods,
    pub thd: *mut ::std::os::raw::c_void,
    pub unbuffered_fetch_owner: *mut my_bool,
    pub info_buffer: *mut ::std::os::raw::c_char,
    pub extension: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for st_mysql {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MYSQL = st_mysql;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_mysql_res {
    pub row_count: my_ulonglong,
    pub fields: *mut MYSQL_FIELD,
    pub data: *mut MYSQL_DATA,
    pub data_cursor: *mut MYSQL_ROWS,
    pub lengths: *mut ::std::os::raw::c_ulong,
    pub handle: *mut MYSQL,
    pub methods: *const st_mysql_methods,
    pub row: MYSQL_ROW,
    pub current_row: MYSQL_ROW,
    pub field_alloc: MEM_ROOT,
    pub field_count: ::std::os::raw::c_uint,
    pub current_field: ::std::os::raw::c_uint,
    pub eof: my_bool,
    pub unbuffered_fetch_cancelled: my_bool,
    pub extension: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for st_mysql_res {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MYSQL_RES = st_mysql_res;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_mysql_parameters {
    pub p_max_allowed_packet: *mut ::std::os::raw::c_ulong,
    pub p_net_buffer_length: *mut ::std::os::raw::c_ulong,
    pub extension: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for st_mysql_parameters {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MYSQL_PARAMETERS = st_mysql_parameters;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum enum_mysql_stmt_state {
    MYSQL_STMT_INIT_DONE = 1,
    MYSQL_STMT_PREPARE_DONE = 2,
    MYSQL_STMT_EXECUTE_DONE = 3,
    MYSQL_STMT_FETCH_DONE = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct st_mysql_bind {
    pub length: *mut ::std::os::raw::c_ulong,
    pub is_null: *mut my_bool,
    pub buffer: *mut ::std::os::raw::c_void,
    pub error: *mut my_bool,
    pub row_ptr: *mut ::std::os::raw::c_uchar,
    pub store_param_func: ::std::option::Option<unsafe extern "C" fn(net:
                                                                         *mut NET,
                                                                     param:
                                                                         *mut st_mysql_bind)>,
    pub fetch_result: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut st_mysql_bind,
                                                                 arg2:
                                                                     *mut MYSQL_FIELD,
                                                                 row:
                                                                     *mut *mut ::std::os::raw::c_uchar)>,
    pub skip_result: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut st_mysql_bind,
                                                                arg2:
                                                                    *mut MYSQL_FIELD,
                                                                row:
                                                                    *mut *mut ::std::os::raw::c_uchar)>,
    pub buffer_length: ::std::os::raw::c_ulong,
    pub offset: ::std::os::raw::c_ulong,
    pub length_value: ::std::os::raw::c_ulong,
    pub param_number: ::std::os::raw::c_uint,
    pub pack_length: ::std::os::raw::c_uint,
    pub buffer_type: enum_field_types,
    pub error_value: my_bool,
    pub is_unsigned: my_bool,
    pub long_data_used: my_bool,
    pub is_null_value: my_bool,
    pub extension: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for st_mysql_bind {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MYSQL_BIND = st_mysql_bind;
pub enum st_mysql_stmt_extension { }
#[repr(C)]
#[derive(Copy)]
pub struct st_mysql_stmt {
    pub mem_root: MEM_ROOT,
    pub list: LIST,
    pub mysql: *mut MYSQL,
    pub params: *mut MYSQL_BIND,
    pub bind: *mut MYSQL_BIND,
    pub fields: *mut MYSQL_FIELD,
    pub result: MYSQL_DATA,
    pub data_cursor: *mut MYSQL_ROWS,
    pub read_row_func: ::std::option::Option<unsafe extern "C" fn(stmt:
                                                                      *mut st_mysql_stmt,
                                                                  row:
                                                                      *mut *mut ::std::os::raw::c_uchar)
                                                 -> ::std::os::raw::c_int>,
    pub affected_rows: my_ulonglong,
    pub insert_id: my_ulonglong,
    pub stmt_id: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub prefetch_rows: ::std::os::raw::c_ulong,
    pub server_status: ::std::os::raw::c_uint,
    pub last_errno: ::std::os::raw::c_uint,
    pub param_count: ::std::os::raw::c_uint,
    pub field_count: ::std::os::raw::c_uint,
    pub state: enum_mysql_stmt_state,
    pub last_error: [::std::os::raw::c_char; 512usize],
    pub sqlstate: [::std::os::raw::c_char; 6usize],
    pub send_types_to_server: my_bool,
    pub bind_param_done: my_bool,
    pub bind_result_done: ::std::os::raw::c_uchar,
    pub unbuffered_fetch_cancelled: my_bool,
    pub update_max_length: my_bool,
    pub extension: *mut st_mysql_stmt_extension,
}
impl ::std::clone::Clone for st_mysql_stmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for st_mysql_stmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MYSQL_STMT = st_mysql_stmt;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum enum_stmt_attr_type {
    STMT_ATTR_UPDATE_MAX_LENGTH = 0,
    STMT_ATTR_CURSOR_TYPE = 1,
    STMT_ATTR_PREFETCH_ROWS = 2,
}
#[link(name = "mysqlclient", kind = "dylib")]
extern "C" {
    pub static mut mysql_port: ::std::os::raw::c_uint;
    pub static mut mysql_unix_port: *mut ::std::os::raw::c_char;
    pub static mut sql_protocol_typelib: TYPELIB;
}
#[link(name = "mysqlclient", kind = "dylib")]
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
    pub fn my_net_init(net: *mut NET, vio: *mut Vio) -> my_bool;
    pub fn my_net_local_init(net: *mut NET);
    pub fn net_end(net: *mut NET);
    pub fn net_clear(net: *mut NET, clear_buffer: my_bool);
    pub fn net_realloc(net: *mut NET, length: size_t) -> my_bool;
    pub fn net_flush(net: *mut NET) -> my_bool;
    pub fn my_net_write(net: *mut NET, packet: *const ::std::os::raw::c_uchar,
                        len: size_t) -> my_bool;
    pub fn net_write_command(net: *mut NET, command: ::std::os::raw::c_uchar,
                             header: *const ::std::os::raw::c_uchar,
                             head_len: size_t,
                             packet: *const ::std::os::raw::c_uchar,
                             len: size_t) -> my_bool;
    pub fn net_real_write(net: *mut NET,
                          packet: *const ::std::os::raw::c_uchar, len: size_t)
     -> ::std::os::raw::c_int;
    pub fn my_net_read(net: *mut NET) -> ::std::os::raw::c_ulong;
    pub fn my_connect(s: my_socket, name: *const sockaddr,
                      namelen: ::std::os::raw::c_uint,
                      timeout: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn randominit(arg1: *mut rand_struct, seed1: ::std::os::raw::c_ulong,
                      seed2: ::std::os::raw::c_ulong);
    pub fn my_rnd(arg1: *mut rand_struct) -> ::std::os::raw::c_double;
    pub fn create_random_string(to: *mut ::std::os::raw::c_char,
                                length: ::std::os::raw::c_uint,
                                rand_st: *mut rand_struct);
    pub fn hash_password(to: *mut ::std::os::raw::c_ulong,
                         password: *const ::std::os::raw::c_char,
                         password_len: ::std::os::raw::c_uint);
    pub fn make_scrambled_password_323(to: *mut ::std::os::raw::c_char,
                                       password:
                                           *const ::std::os::raw::c_char);
    pub fn scramble_323(to: *mut ::std::os::raw::c_char,
                        message: *const ::std::os::raw::c_char,
                        password: *const ::std::os::raw::c_char);
    pub fn check_scramble_323(reply: *const ::std::os::raw::c_uchar,
                              message: *const ::std::os::raw::c_char,
                              salt: *mut ::std::os::raw::c_ulong) -> my_bool;
    pub fn get_salt_from_password_323(res: *mut ::std::os::raw::c_ulong,
                                      password:
                                          *const ::std::os::raw::c_char);
    pub fn make_password_from_salt_323(to: *mut ::std::os::raw::c_char,
                                       salt: *const ::std::os::raw::c_ulong);
    pub fn make_scrambled_password(to: *mut ::std::os::raw::c_char,
                                   password: *const ::std::os::raw::c_char);
    pub fn scramble(to: *mut ::std::os::raw::c_char,
                    message: *const ::std::os::raw::c_char,
                    password: *const ::std::os::raw::c_char);
    pub fn check_scramble(reply: *const ::std::os::raw::c_uchar,
                          message: *const ::std::os::raw::c_char,
                          hash_stage2: *const ::std::os::raw::c_uchar)
     -> my_bool;
    pub fn get_salt_from_password(res: *mut ::std::os::raw::c_uchar,
                                  password: *const ::std::os::raw::c_char);
    pub fn make_password_from_salt(to: *mut ::std::os::raw::c_char,
                                   hash_stage2:
                                       *const ::std::os::raw::c_uchar);
    pub fn octet2hex(to: *mut ::std::os::raw::c_char,
                     str: *const ::std::os::raw::c_char,
                     len: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_char;
    pub fn get_tty_password(opt_message: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn mysql_errno_to_sqlstate(mysql_errno: ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
    pub fn my_thread_init() -> my_bool;
    pub fn my_thread_end();
    pub fn list_add(root: *mut LIST, element: *mut LIST) -> *mut LIST;
    pub fn list_delete(root: *mut LIST, element: *mut LIST) -> *mut LIST;
    pub fn list_cons(data: *mut ::std::os::raw::c_void, root: *mut LIST)
     -> *mut LIST;
    pub fn list_reverse(root: *mut LIST) -> *mut LIST;
    pub fn list_free(root: *mut LIST, free_data: ::std::os::raw::c_uint);
    pub fn list_length(arg1: *mut LIST) -> ::std::os::raw::c_uint;
    pub fn list_walk(arg1: *mut LIST, action: list_walk_action,
                     argument: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
    pub fn find_typeset(x: *mut ::std::os::raw::c_char, typelib: *mut TYPELIB,
                        error_position: *mut ::std::os::raw::c_int)
     -> my_ulonglong;
    pub fn find_type_or_exit(x: *const ::std::os::raw::c_char,
                             typelib: *mut TYPELIB,
                             option: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn find_type(x: *const ::std::os::raw::c_char,
                     typelib: *const TYPELIB, flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn make_type(to: *mut ::std::os::raw::c_char,
                     nr: ::std::os::raw::c_uint, typelib: *mut TYPELIB);
    pub fn get_type(typelib: *mut TYPELIB, nr: ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
    pub fn copy_typelib(root: *mut MEM_ROOT, from: *mut TYPELIB)
     -> *mut TYPELIB;
    pub fn find_set_from_flags(lib: *const TYPELIB,
                               default_name: ::std::os::raw::c_uint,
                               cur_set: my_ulonglong,
                               default_set: my_ulonglong,
                               str: *const ::std::os::raw::c_char,
                               length: ::std::os::raw::c_uint,
                               err_pos: *mut *mut ::std::os::raw::c_char,
                               err_len: *mut ::std::os::raw::c_uint)
     -> my_ulonglong;
    pub fn mysql_server_init(argc: ::std::os::raw::c_int,
                             argv: *mut *mut ::std::os::raw::c_char,
                             groups: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn mysql_server_end();
    pub fn mysql_get_parameters() -> *mut MYSQL_PARAMETERS;
    pub fn mysql_thread_init() -> my_bool;
    pub fn mysql_thread_end();
    pub fn mysql_num_rows(res: *mut MYSQL_RES) -> my_ulonglong;
    pub fn mysql_num_fields(res: *mut MYSQL_RES) -> ::std::os::raw::c_uint;
    pub fn mysql_eof(res: *mut MYSQL_RES) -> my_bool;
    pub fn mysql_fetch_field_direct(res: *mut MYSQL_RES,
                                    fieldnr: ::std::os::raw::c_uint)
     -> *mut MYSQL_FIELD;
    pub fn mysql_fetch_fields(res: *mut MYSQL_RES) -> *mut MYSQL_FIELD;
    pub fn mysql_row_tell(res: *mut MYSQL_RES) -> MYSQL_ROW_OFFSET;
    pub fn mysql_field_tell(res: *mut MYSQL_RES) -> MYSQL_FIELD_OFFSET;
    pub fn mysql_field_count(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
    pub fn mysql_affected_rows(mysql: *mut MYSQL) -> my_ulonglong;
    pub fn mysql_insert_id(mysql: *mut MYSQL) -> my_ulonglong;
    pub fn mysql_errno(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
    pub fn mysql_error(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
    pub fn mysql_sqlstate(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
    pub fn mysql_warning_count(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
    pub fn mysql_info(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
    pub fn mysql_thread_id(mysql: *mut MYSQL) -> ::std::os::raw::c_ulong;
    pub fn mysql_character_set_name(mysql: *mut MYSQL)
     -> *const ::std::os::raw::c_char;
    pub fn mysql_set_character_set(mysql: *mut MYSQL,
                                   csname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn mysql_init(mysql: *mut MYSQL) -> *mut MYSQL;
    pub fn mysql_ssl_set(mysql: *mut MYSQL,
                         key: *const ::std::os::raw::c_char,
                         cert: *const ::std::os::raw::c_char,
                         ca: *const ::std::os::raw::c_char,
                         capath: *const ::std::os::raw::c_char,
                         cipher: *const ::std::os::raw::c_char) -> my_bool;
    pub fn mysql_get_ssl_cipher(mysql: *mut MYSQL)
     -> *const ::std::os::raw::c_char;
    pub fn mysql_change_user(mysql: *mut MYSQL,
                             user: *const ::std::os::raw::c_char,
                             passwd: *const ::std::os::raw::c_char,
                             db: *const ::std::os::raw::c_char) -> my_bool;
    pub fn mysql_real_connect(mysql: *mut MYSQL,
                              host: *const ::std::os::raw::c_char,
                              user: *const ::std::os::raw::c_char,
                              passwd: *const ::std::os::raw::c_char,
                              db: *const ::std::os::raw::c_char,
                              port: ::std::os::raw::c_uint,
                              unix_socket: *const ::std::os::raw::c_char,
                              clientflag: ::std::os::raw::c_ulong)
     -> *mut MYSQL;
    pub fn mysql_select_db(mysql: *mut MYSQL,
                           db: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn mysql_query(mysql: *mut MYSQL, q: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn mysql_send_query(mysql: *mut MYSQL,
                            q: *const ::std::os::raw::c_char,
                            length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
    pub fn mysql_real_query(mysql: *mut MYSQL,
                            q: *const ::std::os::raw::c_char,
                            length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
    pub fn mysql_store_result(mysql: *mut MYSQL) -> *mut MYSQL_RES;
    pub fn mysql_use_result(mysql: *mut MYSQL) -> *mut MYSQL_RES;
    pub fn mysql_get_character_set_info(mysql: *mut MYSQL,
                                        charset: *mut MY_CHARSET_INFO);
    pub fn mysql_set_local_infile_handler(mysql: *mut MYSQL,
                                          local_infile_init:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut *mut ::std::os::raw::c_void,
                                                                                         arg2:
                                                                                             *const ::std::os::raw::c_char,
                                                                                         arg3:
                                                                                             *mut ::std::os::raw::c_void)
                                                                        ->
                                                                            ::std::os::raw::c_int>,
                                          local_infile_read:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void,
                                                                                         arg2:
                                                                                             *mut ::std::os::raw::c_char,
                                                                                         arg3:
                                                                                             ::std::os::raw::c_uint)
                                                                        ->
                                                                            ::std::os::raw::c_int>,
                                          local_infile_end:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void)>,
                                          local_infile_error:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void,
                                                                                         arg2:
                                                                                             *mut ::std::os::raw::c_char,
                                                                                         arg3:
                                                                                             ::std::os::raw::c_uint)
                                                                        ->
                                                                            ::std::os::raw::c_int>,
                                          arg1: *mut ::std::os::raw::c_void);
    pub fn mysql_set_local_infile_default(mysql: *mut MYSQL);
    pub fn mysql_shutdown(mysql: *mut MYSQL,
                          shutdown_level: mysql_enum_shutdown_level)
     -> ::std::os::raw::c_int;
    pub fn mysql_dump_debug_info(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
    pub fn mysql_refresh(mysql: *mut MYSQL,
                         refresh_options: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn mysql_kill(mysql: *mut MYSQL, pid: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
    pub fn mysql_set_server_option(mysql: *mut MYSQL,
                                   option: enum_mysql_set_option)
     -> ::std::os::raw::c_int;
    pub fn mysql_ping(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
    pub fn mysql_stat(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
    pub fn mysql_get_server_info(mysql: *mut MYSQL)
     -> *const ::std::os::raw::c_char;
    pub fn mysql_get_client_info() -> *const ::std::os::raw::c_char;
    pub fn mysql_get_client_version() -> ::std::os::raw::c_ulong;
    pub fn mysql_get_host_info(mysql: *mut MYSQL)
     -> *const ::std::os::raw::c_char;
    pub fn mysql_get_server_version(mysql: *mut MYSQL)
     -> ::std::os::raw::c_ulong;
    pub fn mysql_get_proto_info(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
    pub fn mysql_list_dbs(mysql: *mut MYSQL,
                          wild: *const ::std::os::raw::c_char)
     -> *mut MYSQL_RES;
    pub fn mysql_list_tables(mysql: *mut MYSQL,
                             wild: *const ::std::os::raw::c_char)
     -> *mut MYSQL_RES;
    pub fn mysql_list_processes(mysql: *mut MYSQL) -> *mut MYSQL_RES;
    pub fn mysql_options(mysql: *mut MYSQL, option: mysql_option,
                         arg: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn mysql_free_result(result: *mut MYSQL_RES);
    pub fn mysql_data_seek(result: *mut MYSQL_RES, offset: my_ulonglong);
    pub fn mysql_row_seek(result: *mut MYSQL_RES, offset: MYSQL_ROW_OFFSET)
     -> MYSQL_ROW_OFFSET;
    pub fn mysql_field_seek(result: *mut MYSQL_RES,
                            offset: MYSQL_FIELD_OFFSET) -> MYSQL_FIELD_OFFSET;
    pub fn mysql_fetch_row(result: *mut MYSQL_RES) -> MYSQL_ROW;
    pub fn mysql_fetch_lengths(result: *mut MYSQL_RES)
     -> *mut ::std::os::raw::c_ulong;
    pub fn mysql_fetch_field(result: *mut MYSQL_RES) -> *mut MYSQL_FIELD;
    pub fn mysql_list_fields(mysql: *mut MYSQL,
                             table: *const ::std::os::raw::c_char,
                             wild: *const ::std::os::raw::c_char)
     -> *mut MYSQL_RES;
    pub fn mysql_escape_string(to: *mut ::std::os::raw::c_char,
                               from: *const ::std::os::raw::c_char,
                               from_length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
    pub fn mysql_hex_string(to: *mut ::std::os::raw::c_char,
                            from: *const ::std::os::raw::c_char,
                            from_length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
    pub fn mysql_real_escape_string(mysql: *mut MYSQL,
                                    to: *mut ::std::os::raw::c_char,
                                    from: *const ::std::os::raw::c_char,
                                    length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
    pub fn mysql_debug(debug: *const ::std::os::raw::c_char);
    pub fn myodbc_remove_escape(mysql: *mut MYSQL,
                                name: *mut ::std::os::raw::c_char);
    pub fn mysql_thread_safe() -> ::std::os::raw::c_uint;
    pub fn mysql_embedded() -> my_bool;
    pub fn mysql_read_query_result(mysql: *mut MYSQL) -> my_bool;
    pub fn mysql_stmt_init(mysql: *mut MYSQL) -> *mut MYSQL_STMT;
    pub fn mysql_stmt_prepare(stmt: *mut MYSQL_STMT,
                              query: *const ::std::os::raw::c_char,
                              length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
    pub fn mysql_stmt_execute(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
    pub fn mysql_stmt_fetch(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
    pub fn mysql_stmt_fetch_column(stmt: *mut MYSQL_STMT,
                                   bind_arg: *mut MYSQL_BIND,
                                   column: ::std::os::raw::c_uint,
                                   offset: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
    pub fn mysql_stmt_store_result(stmt: *mut MYSQL_STMT)
     -> ::std::os::raw::c_int;
    pub fn mysql_stmt_param_count(stmt: *mut MYSQL_STMT)
     -> ::std::os::raw::c_ulong;
    pub fn mysql_stmt_attr_set(stmt: *mut MYSQL_STMT,
                               attr_type: enum_stmt_attr_type,
                               attr: *const ::std::os::raw::c_void)
     -> my_bool;
    pub fn mysql_stmt_attr_get(stmt: *mut MYSQL_STMT,
                               attr_type: enum_stmt_attr_type,
                               attr: *mut ::std::os::raw::c_void) -> my_bool;
    pub fn mysql_stmt_bind_param(stmt: *mut MYSQL_STMT, bnd: *mut MYSQL_BIND)
     -> my_bool;
    pub fn mysql_stmt_bind_result(stmt: *mut MYSQL_STMT, bnd: *mut MYSQL_BIND)
     -> my_bool;
    pub fn mysql_stmt_close(stmt: *mut MYSQL_STMT) -> my_bool;
    pub fn mysql_stmt_reset(stmt: *mut MYSQL_STMT) -> my_bool;
    pub fn mysql_stmt_free_result(stmt: *mut MYSQL_STMT) -> my_bool;
    pub fn mysql_stmt_send_long_data(stmt: *mut MYSQL_STMT,
                                     param_number: ::std::os::raw::c_uint,
                                     data: *const ::std::os::raw::c_char,
                                     length: ::std::os::raw::c_ulong)
     -> my_bool;
    pub fn mysql_stmt_result_metadata(stmt: *mut MYSQL_STMT)
     -> *mut MYSQL_RES;
    pub fn mysql_stmt_param_metadata(stmt: *mut MYSQL_STMT) -> *mut MYSQL_RES;
    pub fn mysql_stmt_errno(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_uint;
    pub fn mysql_stmt_error(stmt: *mut MYSQL_STMT)
     -> *const ::std::os::raw::c_char;
    pub fn mysql_stmt_sqlstate(stmt: *mut MYSQL_STMT)
     -> *const ::std::os::raw::c_char;
    pub fn mysql_stmt_row_seek(stmt: *mut MYSQL_STMT,
                               offset: MYSQL_ROW_OFFSET) -> MYSQL_ROW_OFFSET;
    pub fn mysql_stmt_row_tell(stmt: *mut MYSQL_STMT) -> MYSQL_ROW_OFFSET;
    pub fn mysql_stmt_data_seek(stmt: *mut MYSQL_STMT, offset: my_ulonglong);
    pub fn mysql_stmt_num_rows(stmt: *mut MYSQL_STMT) -> my_ulonglong;
    pub fn mysql_stmt_affected_rows(stmt: *mut MYSQL_STMT) -> my_ulonglong;
    pub fn mysql_stmt_insert_id(stmt: *mut MYSQL_STMT) -> my_ulonglong;
    pub fn mysql_stmt_field_count(stmt: *mut MYSQL_STMT)
     -> ::std::os::raw::c_uint;
    pub fn mysql_commit(mysql: *mut MYSQL) -> my_bool;
    pub fn mysql_rollback(mysql: *mut MYSQL) -> my_bool;
    pub fn mysql_autocommit(mysql: *mut MYSQL, auto_mode: my_bool) -> my_bool;
    pub fn mysql_more_results(mysql: *mut MYSQL) -> my_bool;
    pub fn mysql_next_result(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
    pub fn mysql_stmt_next_result(stmt: *mut MYSQL_STMT)
     -> ::std::os::raw::c_int;
    pub fn mysql_close(sock: *mut MYSQL);
}
